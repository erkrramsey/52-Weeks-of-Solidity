<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ERC-NodeGraph: Award-Winning All-in-One Website</title>

    <!-- SEO Meta Tags -->
    <meta name="description"
        content="ERC-NodeGraph revolutionizes token relationships on the blockchain by visualizing and managing complex networks of ERC-20, ERC-721, and ERC-1155 tokens.">
    <meta name="keywords"
        content="ERC-NodeGraph, Blockchain, Token Relationships, ERC-20, ERC-721, ERC-1155, D3.js, NFT, DeFi">
    <meta property="og:title" content="ERC-NodeGraph: Award-Winning All-in-One Website">
    <meta property="og:description"
        content="Connect, interact, and build complex networks on the blockchain using ERC-NodeGraph.">
    <meta property="og:image" content="https://example.com/og-image.jpg">
    <meta property="og:url" content="https://erc-nodegraph.com">
    <meta name="twitter:card" content="summary_large_image">

    <!-- D3.js for Graph Visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.4/d3.min.js" integrity="sha512-..."
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

    <!-- CSS Styles -->
    <style>
        /* RESET & BASE STYLES */
        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Poppins', sans-serif;
            color: #333;
            background-color: #f7f7f7;
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            text-decoration: none;
            color: inherit;
        }

        ul {
            list-style: none;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin-bottom: 10px;
        }

        p {
            margin: 15px 0;
        }

        section {
            padding: 60px 20px;
        }

        pre,
        code {
            background: #f9f9f9;
            padding: 20px;
            display: block;
            overflow-x: auto;
            font-family: "Courier New", Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            border-radius: 6px;
        }

        .container {
            width: 90%;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* DARK MODE STYLES */
        body.dark-mode {
            background-color: #121212;
            color: #e0e0e0;
        }

        body.dark-mode pre,
        body.dark-mode code {
            background: #1e1e1e;
            color: #e0e0e0;
        }

        body.dark-mode .hero {
            background: linear-gradient(135deg, #1f4037 0%, #99f2c8 100%);
        }

        body.dark-mode header {
            background: #1f1f1f;
        }

        /* HEADER & NAVIGATION */
        header {
            background: #333;
            color: #fff;
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 999;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: background 0.3s;
        }

        header .container {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        header h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        nav ul {
            display: flex;
            gap: 25px;
        }

        nav li {
            position: relative;
        }

        nav a {
            color: #fff;
            font-weight: 600;
            transition: color 0.3s, transform 0.3s;
            position: relative;
        }

        nav a::after {
            content: '';
            display: block;
            width: 0;
            height: 2px;
            background: #fff;
            transition: width 0.3s;
            position: absolute;
            bottom: -5px;
            left: 0;
        }

        nav a:hover::after,
        nav a:focus::after {
            width: 100%;
        }

        nav a:hover {
            color: #eee;
            transform: scale(1.05);
        }

        /* MOBILE MENU */
        .mobile-menu-button {
            display: none;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            nav ul {
                flex-direction: column;
                position: absolute;
                top: 60px;
                right: 20px;
                background: #333;
                padding: 20px;
                border-radius: 8px;
                display: none;
                width: 200px;
            }

            nav ul.active {
                display: flex;
            }

            .mobile-menu-button {
                display: block;
            }
        }

        /* HERO SECTION */
        .hero {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: #fff;
            text-align: center;
            padding: 100px 20px;
            position: relative;
            overflow: hidden;
            transition: background 0.3s;
        }

        .hero::before {
            content: "";
            position: absolute;
            top: 0;
            left: -50%;
            width: 200%;
            height: 100%;
            background: radial-gradient(circle at 50%, rgba(255, 255, 255, 0.1) 20%, transparent 60%);
            animation: swirl 8s infinite alternate;
            opacity: 0.7;
            pointer-events: none;
        }

        @keyframes swirl {
            0% {
                transform: translateY(0) rotate(0);
            }

            100% {
                transform: translateY(-10%) rotate(10deg);
            }
        }

        .hero h2 {
            font-size: 42px;
            margin-bottom: 20px;
            animation: fadeInDown 1s ease both;
        }

        .hero p {
            font-size: 18px;
            margin-bottom: 30px;
            animation: fadeInUp 1s ease both;
        }

        @keyframes fadeInDown {
            0% {
                opacity: 0;
                transform: translateY(-20px);
            }

            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }

            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .cta-button {
            display: inline-block;
            background-color: #fff;
            color: #2575fc;
            padding: 12px 24px;
            border-radius: 4px;
            font-weight: bold;
            transition: background-color 0.3s, color 0.3s, transform 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .cta-button:hover,
        .cta-button:focus {
            background-color: #2575fc;
            color: #fff;
            transform: translateY(-2px);
        }

        /* DARK MODE TOGGLE */
        .dark-mode-toggle {
            cursor: pointer;
            font-size: 20px;
            background: none;
            border: none;
            color: #fff;
            transition: color 0.3s;
        }

        .dark-mode-toggle:hover,
        .dark-mode-toggle:focus {
            color: #e0e0e0;
        }

        /* MAIN SECTIONS */
        .main-section h2 {
            margin-bottom: 20px;
            font-size: 28px;
            text-align: center;
            font-weight: 700;
        }

        .main-section p {
            font-size: 16px;
            line-height: 1.7;
            margin-bottom: 30px;
            text-align: center;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        /* DEMO SECTION */
        .demo-section {
            background-color: #fff;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
        }

        #graph-container {
            width: 100%;
            max-width: 800px;
            height: 400px;
            margin: 0 auto;
            background-color: #fafafa;
            border: 2px dashed #ccc;
            border-radius: 8px;
            position: relative;
        }

        .demo-controls {
            text-align: center;
            margin-top: 30px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .demo-controls input,
        .demo-controls select,
        .demo-controls button {
            margin: 5px;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            transition: border 0.3s;
        }

        .demo-controls input:focus,
        .demo-controls select:focus {
            border-color: #2575fc;
            outline: none;
        }

        .demo-controls button {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: #fff;
            font-weight: 600;
            border: none;
            transition: 0.3s;
            cursor: pointer;
        }

        .demo-controls button:hover,
        .demo-controls button:focus {
            opacity: 0.8;
        }

        .node {
            cursor: pointer;
            transition: fill 0.3s, r 0.2s;
        }

        .node:hover {
            fill: #ff4081;
            r: 14;
        }

        /* CONTACT SECTION */
        .contact-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .contact-content form {
            width: 100%;
            max-width: 500px;
            background-color: #fff;
            padding: 20px;
            border-radius: 6px;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s, box-shadow 0.3s;
        }

        body.dark-mode .contact-content form {
            background-color: #1e1e1e;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.1);
        }

        .contact-content form .form-group {
            margin-bottom: 15px;
        }

        .contact-content form label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            letter-spacing: 0.5px;
        }

        .contact-content form input,
        .contact-content form textarea {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border-radius: 4px;
            border: 1px solid #ccc;
            transition: border 0.2s;
        }

        body.dark-mode .contact-content form input,
        body.dark-mode .contact-content form textarea {
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #555;
        }

        .contact-content form input:focus,
        .contact-content form textarea:focus {
            border-color: #2575fc;
            outline: none;
        }

        .contact-content form button {
            background-color: #2575fc;
            color: #fff;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
        }

        .contact-content form button:hover,
        .contact-content form button:focus {
            background-color: #6a11cb;
            transform: translateY(-2px);
        }

        /* USE CASES STYLES */
        .section {
            margin: 40px auto;
            max-width: 1000px;
            background: #fff;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
            margin-bottom: 30px;
            transition: background 0.3s, box-shadow 0.3s;
        }

        body.dark-mode .section {
            background: #1e1e1e;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.1);
        }

        .section h2 {
            font-size: 24px;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
        }

        body.dark-mode .section h2 {
            color: #e0e0e0;
        }

        .section h3 {
            font-size: 18px;
            margin-top: 15px;
            margin-bottom: 8px;
            color: #444;
        }

        body.dark-mode .section h3 {
            color: #cccccc;
        }

        .section ul {
            list-style: disc;
            margin-left: 20px;
        }

        .section ul li strong {
            color: #2575fc;
        }

        /* FOOTER */
        footer {
            background-color: #333;
            color: #fff;
            padding: 20px 0;
            text-align: center;
            margin-top: 40px;
            transition: background 0.3s, color 0.3s;
        }

        body.dark-mode footer {
            background-color: #1f1f1f;
            color: #e0e0e0;
        }

        footer p {
            margin: 0;
            font-size: 14px;
            letter-spacing: 0.5px;
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            header .container {
                flex-direction: column;
                gap: 10px;
            }

            nav ul {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }

            .hero h2 {
                font-size: 32px;
            }

            .demo-controls {
                flex-direction: column;
                align-items: center;
            }

            #graph-container {
                height: 300px;
            }

            .section {
                padding: 20px;
            }
        }

        /* D3.js GRAPH STYLES */
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }

        .node {
            stroke: #fff;
            stroke-width: 1.5px;
        }

        /* DARK MODE GRAPH STYLES */
        body.dark-mode .link {
            stroke: #555;
        }

        body.dark-mode .node {
            stroke: #333;
        }

        /* SMOOTH SCROLLING */
        html {
            scroll-behavior: smooth;
        }

        /* ACTIVE NAV LINK */
        nav a.active {
            color: #ff4081;
        }
    </style>
</head>

<body>

    <!-- HEADER -->
    <header>
        <div class="container">
            <h1>ERC-NodeGraph</h1>
            <nav aria-label="Main Navigation">
                <button class="mobile-menu-button" aria-label="Toggle Menu">
                    ☰
                </button>
                <ul>
                    <li><a href="#hero">Home</a></li>
                    <li><a href="#proposal">EIP Proposal</a></li>
                    <li><a href="#implementation">Implementation</a></li>
                    <li><a href="#use-cases">Use Cases</a></li>
                    <li><a href="#demo">Demo</a></li>
                    <li><a href="#contact">Contact</a></li>
                    <li><button class="dark-mode-toggle" aria-label="Toggle Dark Mode">🌙</button></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- HERO SECTION -->
    <section id="hero" class="hero" aria-labelledby="hero-heading">
        <h2 id="hero-heading">Revolutionizing Token Relationships</h2>
        <p>Connect, interact, and build complex networks on the blockchain using ERC-NodeGraph.</p>
        <a href="#proposal" class="cta-button">Learn More</a>
    </section>

    <!-- EIP PROPOSAL SECTION -->
    <section id="proposal" class="main-section" aria-labelledby="proposal-heading">
        <div class="container">
            <h2 id="proposal-heading">1. ERC-NodeGraph EIP-Style Proposal</h2>
            <p>
                ERC-NodeGraph treats each <strong>token</strong> as a <strong>node</strong> in a graph, with
                <strong>edges</strong>
                representing on-chain relationships or data flows—friendships, supply chain dependencies, genealogies,
                cross-NFT references, or payment routes. Below is a formal EIP-style proposal describing the
                rationale, specification, and essential features.
            </p>
            <pre><code>
# Preamble

EIP: <to be assigned>
Title: ERC-NodeGraph - Tokens as Nodes in a Graph with Edges Representing Relationships
Author: [BoredNBased] <BoredNBased@Gmail.com>
Type: Standards Track
Category: ERC
Status: Draft
Created: 2024-04-27

# Abstract

The ERC-NodeGraph standard defines a non-fungible token (NFT) system where each token represents
a node in a graph structure. The contract tracks relationships (edges) between these nodes, enabling
complex network representations such as social connections, supply chains, genealogies, cross-NFT
payment routes. This structure facilitates advanced utilities like network-based governance,
influence scoring, and multi-asset synergy.

# Motivation

Existing ERC-721 tokens are unique but do not store relationships. ERC-NodeGraph
enables tokens to serve as graph nodes, capturing dynamic, on-chain relationships that can be used for
multi-token bridging, genealogies, supply chain tracking, or social graphs.

# Specification

interface IERCNodeGraph is IERC721 {
    event NodeCreated(uint256 indexed nodeId, address indexed owner);
    event ConnectionAdded(uint256 indexed fromNode, uint256 indexed toNode);
    event ConnectionRemoved(uint256 indexed fromNode, uint256 indexed toNode);

    function createNode(address owner) external returns (uint256 nodeId);
    function addConnection(uint256 fromNode, uint256 toNode) external;
    function removeConnection(uint256 fromNode, uint256 toNode) external;
    function getConnections(uint256 nodeId) external view returns (uint256[] memory);
    function transferNode(uint256 nodeId, address newOwner) external;
}

# Rationale

1. Graph Representation: On-chain tokens can connect to each other, forming advanced relational data.
2. Interoperability: Builds on ERC-721 for compatibility with existing NFT tools.
3. Flexibility: Supports unidirectional/bidirectional edges for varied use cases.

# Security Considerations

- Access Control: Only node owners can modify their node’s connections.
- Input Validation: Must ensure node existence, avoid self-connections, and prevent duplicates.
- Reentrancy: Following OpenZeppelin patterns mitigates vulnerabilities.

# References

- ERC-721: Non-Fungible Token Standard
- OpenZeppelin Contracts
- Ethereum Improvement Proposals (eips.ethereum.org)
            </code></pre>
            <p>
                By framing tokens as graph nodes, ERC-NodeGraph unlocks a world of multi-token or multi-NFT
                relationships—from simple references to complex on-chain data flows or bridging solutions.
            </p>
        </div>
    </section>

    <!-- IMPLEMENTATION SECTION -->
    <section id="implementation" class="main-section" aria-labelledby="implementation-heading">
        <div class="container">
            <h2 id="implementation-heading">2. Full ERC-NodeGraph Solidity Implementation</h2>
            <p>
                Below is a <strong>Solidity contract</strong> implementing ERC-NodeGraph using OpenZeppelin.
                It demonstrates how a node’s ID corresponds to an ERC-721 token and how connections (edges)
                are stored, allowing each node (token) to link to multiple other tokens in dynamic,
                on-chain architectures—e.g., genealogies, multi-asset references, supply chain steps, etc.
            </p>
            <pre><code>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title MultiTokenGraph
 * @dev Allows graphing and connecting ERC-20, ERC-721, and ERC-1155 tokens.
 */
contract MultiTokenGraph is ERC721, Ownable {
    enum TokenType {
        ERC20,
        ERC721,
        ERC1155
    }

    struct Node {
        uint256 nodeId;
        address tokenAddress;
        TokenType tokenType;
        mapping(uint256 => bool) connections;
        string metadata;
        bool exists;
    }

    mapping(uint256 => Node) private _nodes;
    uint256 private _nodeCount;
    mapping(address => bool) private _admins;

    event NodeCreated(
        uint256 indexed nodeId,
        address indexed tokenAddress,
        TokenType tokenType,
        string metadata
    );
    event ConnectionAdded(
        uint256 indexed fromNode,
        uint256 indexed toNode,
        bool bidirectional
    );
    event ConnectionRemoved(
        uint256 indexed fromNode,
        uint256 indexed toNode,
        bool bidirectional
    );
    event AdminAdded(address indexed admin);
    event AdminRemoved(address indexed admin);

    constructor(string memory name_, string memory symbol_)
        ERC721(name_, symbol_)
    {
        _admins[msg.sender] = true;
    }

    modifier onlyAdmin() {
        require(_admins[msg.sender], "Not an admin");
        _;
    }

    /**
     * @dev Checks if a node exists.
     */
    function nodeExists(uint256 nodeId) public view returns (bool) {
        return _nodes[nodeId].exists;
    }

    /**
     * @dev Adds an admin for managing the graph.
     */
    function addAdmin(address admin) external onlyOwner {
        _admins[admin] = true;
        emit AdminAdded(admin);
    }

    /**
     * @dev Removes an admin.
     */
    function removeAdmin(address admin) external onlyOwner {
        _admins[admin] = false;
        emit AdminRemoved(admin);
    }

    /**
     * @dev Creates a new node for a token (ERC-20, ERC-721, ERC-1155).
     */
    function createNode(
        address tokenAddress,
        TokenType tokenType,
        string calldata metadata
    )
        internal
        returns (
            uint256 nodeId
        )
    {
        _nodeCount += 1;
        nodeId = _nodeCount;

        _nodes[nodeId].tokenAddress = tokenAddress;
        _nodes[nodeId].tokenType = tokenType;
        _nodes[nodeId].metadata = metadata;
        _nodes[nodeId].exists = true;

        emit NodeCreated(nodeId, tokenAddress, tokenType, metadata);
    }

    /**
     * @dev Batch creation of nodes.
     */
    function batchCreateNodes(
        address[] calldata tokenAddresses,
        TokenType[] calldata tokenTypes,
        string[] calldata metadataArray
    ) external onlyAdmin {
        require(
            tokenAddresses.length == tokenTypes.length &&
            tokenTypes.length == metadataArray.length,
            "Array length mismatch"
        );
        for (uint256 i = 0; i < tokenAddresses.length; i++) {
            createNode(tokenAddresses[i], tokenTypes[i], metadataArray[i]);
        }
    }

    /**
     * @dev Adds a connection between two nodes.
     */
    function addConnection(
        uint256 fromNode,
        uint256 toNode,
        bool bidirectional
    ) internal {
        require(
            nodeExists(fromNode) && nodeExists(toNode),
            "Node does not exist"
        );

        _nodes[fromNode].connections[toNode] = true;
        if (bidirectional) {
            _nodes[toNode].connections[fromNode] = true;
        }

        emit ConnectionAdded(fromNode, toNode, bidirectional);
    }

    /**
     * @dev Adds multiple connections at once.
     */
    function batchAddConnections(
        uint256[] calldata fromNodes,
        uint256[] calldata toNodes,
        bool[] calldata bidirectional
    ) external onlyAdmin {
        require(
            fromNodes.length == toNodes.length &&
            toNodes.length == bidirectional.length,
            "Array length mismatch"
        );

        for (uint256 i = 0; i < fromNodes.length; i++) {
            addConnection(fromNodes[i], toNodes[i], bidirectional[i]);
        }
    }

    /**
     * @dev Removes a connection.
     */
    function removeConnection(
        uint256 fromNode,
        uint256 toNode,
        bool bidirectional
    ) external onlyAdmin {
        require(
            nodeExists(fromNode) && nodeExists(toNode),
            "Node does not exist"
        );

        _nodes[fromNode].connections[toNode] = false;
        if (bidirectional) {
            _nodes[toNode].connections[fromNode] = false;
        }

        emit ConnectionRemoved(fromNode, toNode, bidirectional);
    }

    /**
     * @dev Retrieves all connected node IDs for a given node.
     */
    function getConnections(uint256 nodeId)
        external
        view
        returns (uint256[] memory)
    {
        require(nodeExists(nodeId), "Node does not exist");

        uint256 count = 0;
        uint256[] memory temp = new uint256[](_nodeCount);

        for (uint256 i = 1; i <= _nodeCount; i++) {
            if (_nodes[nodeId].connections[i]) {
                temp[count] = i;
                count++;
            }
        }

        uint256[] memory result = new uint256[](count);
        for (uint256 j = 0; j < count; j++) {
            result[j] = temp[j];
        }

        return result;
    }

    /**
     * @dev Retrieves the metadata for a node.
     */
    function getNode(uint256 nodeId)
        external
        view
        returns (
            address tokenAddress,
            TokenType tokenType,
            string memory metadata
        )
    {
        require(nodeExists(nodeId), "Node does not exist");
        Node storage node = _nodes[nodeId];
        return (node.tokenAddress, node.tokenType, node.metadata);
    }

    /**
     * @dev Retrieves the total number of nodes.
     */
    function totalNodes() external view returns (uint256) {
        return _nodeCount;
    }

    /**
     * @dev Checks if two nodes are connected.
     */
    function isConnected(uint256 fromNode, uint256 toNode)
        external
        view
        returns (bool)
    {
        return _nodes[fromNode].connections[toNode];
    }

    /**
     * @dev Retrieves the number of connections for a given node.
     */
    function getNodeDegree(uint256 nodeId)
        external
        view
        returns (uint256 degree)
    {
        require(nodeExists(nodeId), "Node does not exist");

        uint256 count = 0;
        for (uint256 i = 1; i <= _nodeCount; i++) {
            if (_nodes[nodeId].connections[i]) {
                count++;
            }
        }
        return count;
    }
    </code></pre>
            <p>
                Thanks to <strong>ERC-NodeGraph</strong>, multiple tokens or NFTs can coexist and interconnect,
                forming payment routes, genealogies, or sophisticated cross-collection references
                all anchored on-chain.
            </p>
        </div>
    </section>

    <!-- USE CASES SECTION -->
    <section id="use-cases" class="main-section" aria-labelledby="use-cases-heading">
        <div class="container">
            <h2 id="use-cases-heading">3. Comprehensive Use Cases & Ecosystems</h2>
            <p>
                Below are **18** ecosystems that showcase how ERC-NodeGraph can power diverse relational token
                environments—from social networks to fractional ownership. Adapt these ideas for your own project!
            </p>
            <ol>
                <li><strong>Social Token Ecosystem</strong><br />
                    <em>Description:</em> Build a web of interconnected social tokens representing influencers,
                    creators, or DAOs.<br />
                    <em>Example:</em> A "Degen Social Network" where each influencer’s token is a node, and connections
                    represent collaborations or rivalries. Users earn rewards by connecting influencers through
                    collaborations or exposing rivalries.
                </li>
                <li><strong>Dynamic NFT Ecosystem</strong><br />
                    <em>Description:</em> An NFT world where connections determine the evolution, rarity, or metadata of
                    NFTs.<br />
                    <em>Example:</em> A metaverse where NFT avatars "evolve" by connecting to specific ERC20 tokens or
                    other NFTs. For instance, connecting to a "Potion Token" transforms a standard NFT into a rare
                    "Enchanted" version.
                </li>
                <li><strong>Cross-Token Trading Platform</strong><br />
                    <em>Description:</em> A graph-based DEX where tokens are linked through trading pairs.<br />
                    <em>Example:</em> A decentralized exchange where each node represents a token, and connections are
                    active trading pairs. Users can traverse the graph to find the shortest path for arbitrage between
                    tokens.
                </li>
                <li><strong>Game Asset Ecosystem</strong><br />
                    <em>Description:</em> A network for linking in-game assets across different blockchain games.<br />
                    <em>Example:</em> A gaming multiverse where ERC1155 items from one game link to ERC20 tokens in
                    another, or to achievements in a third. E.g., a "Sword NFT" from Game A connects to a "Token of
                    Valor" used in Game B.
                </li>
                <li><strong>DeFi Yield Ecosystem</strong><br />
                    <em>Description:</em> A yield farming network where nodes represent staking pools, and connections
                    show farming paths.<br />
                    <em>Example:</em> Users connect nodes to create yield chains: e.g., stake Token A to earn Token B,
                    which can be staked in Pool C for another reward, forming a yield optimization graph.
                </li>
                <li><strong>Rivalry Graph Ecosystem</strong><br />
                    <em>Description:</em> A competitive environment where tokens and NFTs battle for dominance.<br />
                    <em>Example:</em> A "Degen Battle Royale" where tokens earn points by forming alliances or attacking
                    rival nodes. Users vote or stake tokens to strengthen alliances, and the graph determines the winner
                    of each round.
                </li>
                <li><strong>Advertising and Marketing Ecosystem</strong><br />
                    <em>Description:</em> A tokenized ad network where brands connect to NFTs and tokens.<br />
                    <em>Example:</em> An ecosystem where brands sponsor "AdNFT" nodes linked to ERC20 or ERC721 nodes.
                    Users interact with ads to earn rewards, creating a tokenized advertising web.
                </li>
                <li><strong>Educational Ecosystem</strong><br />
                    <em>Description:</em> A graph to visualize and incentivize blockchain learning paths.<br />
                    <em>Example:</em> Nodes represent blockchain tutorials or tokens, and users connect them as they
                    complete modules. For instance, a "DeFi 101 Token" connects to an "Advanced Staking Token" after
                    completing specific prerequisites.
                </li>
                <li><strong>Charity and Impact Ecosystem</strong><br />
                    <em>Description:</em> A network to track donations and their real-world impact.<br />
                    <em>Example:</em> Nodes represent ERC20 charity tokens or NFTs issued for donations, and connections
                    visualize how donations flow from donors to projects, ensuring transparent philanthropic tracking.
                </li>
                <li><strong>Meme Coin Ecosystem</strong><br />
                    <em>Description:</em> A chaotic web of meme coins, collaborations, and rug-pull survivors.<br />
                    <em>Example:</em> A "MemeCoin Universe" where each meme coin is a node. Connections represent shared
                    wallets, LP pools, or collaboration events. Users can navigate the graph to find the "most rugged"
                    or "most diamond-handed" coins.
                </li>
                <li><strong>Art Collaboration Ecosystem</strong><br />
                    <em>Description:</em> A graph for linking artists, NFTs, and collections.<br />
                    <em>Example:</em> Artists mint "Collab NFTs" as nodes, connecting them to ERC721 nodes of their
                    personal collections. Fans can buy or bid on the collaboration links themselves, forming a dynamic
                    market of creative partnerships.
                </li>
                <li><strong>Fractional Ownership Ecosystem</strong><br />
                    <em>Description:</em> A network for tracking fractional ownership of high-value assets.<br />
                    <em>Example:</em> Nodes represent ERC721 NFTs, and connections are ERC20 tokens representing
                    fractional shares. Users can reconnect nodes by buying all shares, effectively "defractionalizing"
                    the NFT.
                </li>
                <li><strong>Token Utility Ecosystem</strong><br />
                    <em>Description:</em> A graph showing how different tokens interact or unlock utilities in
                    DApps.<br />
                    <em>Example:</em> A "Degen Graph" where ERC20 nodes represent tokens required to unlock perks—like
                    exclusive NFT mints or governance rights. Connections reveal synergy or friction among various
                    utility tokens.
                </li>
                <li><strong>Gamified Governance Ecosystem</strong><br />
                    <em>Description:</em> A governance system where connections influence voting power or proposal
                    visibility.<br />
                    <em>Example:</em> Nodes are proposals, and users connect tokens to proposals they support. Proposals
                    with more connections gain higher priority in the DAO’s queue, making governance a competitive,
                    game-like process.
                </li>
                <li><strong>Racing and Betting Ecosystem</strong><br />
                    <em>Description:</em> A betting graph where users place bets by creating connections.<br />
                    <em>Example:</em> A "Degen Derby" where horses (ERC721s) are nodes, and connections represent bets.
                    Odds update dynamically as more connections (bets) form around certain horses.
                </li>
                <li><strong>Cross-Chain Ecosystem</strong><br />
                    <em>Description:</em> A graph linking tokens and assets across multiple blockchains.<br />
                    <em>Example:</em> Nodes represent wrapped assets on Ethereum, Solana, or other chains, and
                    connections are bridges or pegging mechanisms. Users can see and utilize cross-chain liquidity
                    paths.
                </li>
                <li><strong>Collector’s Ecosystem</strong><br />
                    <em>Description:</em> A network for NFT collectors to showcase and link their collections.<br />
                    <em>Example:</em> A "Collector’s Graph" where nodes represent entire collections, and connections
                    show trades or shared ownership histories—a badge of honor for top collectors.
                </li>
                <li><strong>Music and Media Ecosystem</strong><br />
                    <em>Description:</em> A network linking media NFTs to their derivatives or remixes.<br />
                    <em>Example:</em> A "Music Graph" where original songs (ERC721) link to remixes or fan-made versions
                    (ERC1155). Users can purchase remix rights or royalties by traversing the connection graph.
                </li>
            </ol>
        </div>
    </section>

    <!-- USE CASES & FIXES SECTION -->
    <section id="expansion" aria-labelledby="expansion-heading">
        <h1 style="text-align: center; margin-top: 40px; font-size: 32px;">
            MultiToken Graph Use Cases
        </h1>

        <div class="section">
            <h2>1️⃣ Visualizing Token Relationships</h2>
            <p>You can map out how different tokens interact:</p>
            <ul>
                <li><strong>ERC-20</strong> → LP Pairs, DAO interactions, cross-chain bridges</li>
                <li><strong>ERC-721 (NFTs)</strong> → Art collections, in-game items, dynamic NFTs</li>
                <li><strong>ERC-1155</strong> → Gaming assets, semi-fungible items</li>
            </ul>
            <h3>✅ Example:</h3>
            <p>
                $TOKEN-A (ERC-20) is linked to an NFT (ERC-721), which is linked to an in-game item (ERC-1155).
            </p>
            <pre class="code">
createNode(tokenAAddress, TokenType.ERC20, "LP Token");
createNode(nftAddress, TokenType.ERC721, "Special NFT");
createNode(gameItemAddress, TokenType.ERC1155, "In-Game Sword");
addConnection(1, 2, true);
addConnection(2, 3, true);
            </pre>
        </div>

        <!-- [Additional sections omitted for brevity; include all sections as in your original code] -->

        <div class="section">
            <h2>💡 Advanced: Batch Processing for Large-Scale Graphs</h2>
            <h3>✅ Batch Create Nodes:</h3>
            <pre class="code">
address[] memory tokenAddresses = [tokenA, tokenB, tokenC];
TokenType[] memory tokenTypes = [TokenType.ERC20, TokenType.ERC721, TokenType.ERC1155];
string[] memory metadataArray = ["Token A", "NFT B", "Item C"];
batchCreateNodes(tokenAddresses, tokenTypes, metadataArray);
            </pre>
            <h3>✅ Batch Connect Nodes:</h3>
            <pre class="code">
uint256[] memory fromNodes = [1, 2, 3];
uint256[] memory toNodes = [2, 3, 1];
bool[] memory bidirectional = [true, false, true];
batchAddConnections(fromNodes, toNodes, bidirectional);
            </pre>
        </div>

        <h2 style="text-align: center; margin-top: 40px; font-size: 28px;">
            🚀 Conclusion
        </h2>
        <p style="text-align: center; max-width: 900px; margin: 0 auto 60px auto;">
            The <strong>MultiTokenGraph</strong> contract allows comprehensive graphing of token relationships
            across ERC-20, ERC-721, and ERC-1155. This is ideal for:
        </p>
        <ul style="max-width: 600px; margin: 0 auto 40px auto; line-height: 1.8;">
            <li>✅ DeFi Liquidity Tracking</li>
            <li>✅ NFT Ownership Mapping</li>
            <li>✅ Gaming Ecosystem Integration</li>
            <li>✅ DAO Governance Visualization</li>
        </ul>
    </section>

    <!-- INTERACTIVE DEMO SECTION -->
    <section id="demo" class="demo-section" aria-labelledby="demo-heading">
        <div class="container">
            <h2 id="demo-heading">4. Interactive Demo: Visualizing Node Relationships</h2>
            <p>
                Try out our <strong>force-directed graph</strong> demo. Add nodes (tokens) and form connections.
            </p>
            <!-- Graph Container -->
            <div id="graph-container" aria-label="Interactive Node Graph"></div>

            <!-- Demo Controls -->
            <div class="demo-controls">
                <input type="text" id="node-name" placeholder="Node Name (e.g. 'Alice' or 'NFT1')"
                    aria-label="Node Name" />
                <button id="add-node">Add Node</button>
                <select id="node-connect-from" aria-label="Connect From"></select>
                <select id="node-connect-to" aria-label="Connect To"></select>
                <button id="add-connection">Add Connection</button>
            </div>
        </div>
    </section>

    <!-- CONTACT SECTION -->
    <section id="contact" class="main-section" aria-labelledby="contact-heading">
        <div class="container">
            <h2 id="contact-heading">6. Contact & Feedback</h2>
            <p>
                Have questions or ideas for integrating ERC-NodeGraph in your project?
                Fill out the form below, and we’ll be in touch.
            </p>
            <div class="contact-content">
                <form id="contact-form" aria-label="Contact Form">
                    <div class="form-group">
                        <label for="name">Name</label>
                        <input type="text" id="name" placeholder="Your Name" required aria-required="true" />
                    </div>
                    <div class="form-group">
                        <label for="email">Email</label>
                        <input type="email" id="email" placeholder="Your Email" required aria-required="true" />
                    </div>
                    <div class="form-group">
                        <label for="message">Message</label>
                        <textarea id="message" rows="5" placeholder="Your Message" required
                            aria-required="true"></textarea>
                    </div>
                    <button type="submit">Send</button>
                </form>
            </div>
        </div>
    </section>

    <!-- FOOTER -->
    <footer>
        <p>&copy; 2025 ERC-NodeGraph. All rights reserved.</p>
    </footer>

    <!-- INLINE JS: INTERACTIVE DEMO, FORM HANDLING, ETC. -->
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const nodes = []; // Each element is { id: "someString" }
            const links = []; // Each element is { source: "stringID", target: "stringID" }
            const width = document.getElementById("graph-container").clientWidth;
            const height = 400;

            // Create an SVG element for D3
            const svg = d3.select("#graph-container")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .call(d3.zoom().on("zoom", function (event) {
                    svg.attr("transform", event.transform);
                }))
                .append("g");

            // D3 force simulation
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).distance(100).id(d => d.id))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2));

            // Helper: get node object by ID
            function getNodeById(id) {
                return nodes.find(n => n.id === id);
            }

            function updateGraph() {
                // LINK elements
                const link = svg.selectAll(".link")
                    .data(links, d => d.source.id + "-" + d.target.id)
                    .join("line")
                    .attr("class", "link")
                    .attr("stroke", "#999")
                    .attr("stroke-width", 2);

                // NODE elements
                const node = svg.selectAll(".node")
                    .data(nodes, d => d.id)
                    .join("circle")
                    .attr("class", "node")
                    .attr("r", 12)
                    .attr("fill", "#6a11cb")
                    .call(drag(simulation));

                // Tooltip
                node.append("title").text(d => d.id);

                // Update simulation
                simulation.nodes(nodes);
                simulation.force("link").links(links);
                simulation.alpha(1).restart();

                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);
                });
            }

            // D3 drag behavior
            function drag(sim) {
                function dragstarted(event, d) {
                    if (!event.active) sim.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                function dragended(event, d) {
                    if (!event.active) sim.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }
                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
            }

            // Update the dropdowns to reflect the current node set
            function updateSelectOptions() {
                const fromSelect = document.getElementById("node-connect-from");
                const toSelect = document.getElementById("node-connect-to");

                fromSelect.innerHTML = "";
                toSelect.innerHTML = "";

                nodes.forEach(node => {
                    const opt1 = document.createElement("option");
                    opt1.value = node.id;
                    opt1.textContent = node.id;
                    fromSelect.appendChild(opt1);

                    const opt2 = document.createElement("option");
                    opt2.value = node.id;
                    opt2.textContent = node.id;
                    toSelect.appendChild(opt2);
                });
            }

            // Add Node Button
            document.getElementById("add-node").addEventListener("click", () => {
                const nodeName = document.getElementById("node-name").value.trim();
                // Prevent duplicates
                if (nodeName && !getNodeById(nodeName)) {
                    nodes.push({ id: nodeName });
                    document.getElementById("node-name").value = "";
                    updateSelectOptions();
                    updateGraph();
                } else if (getNodeById(nodeName)) {
                    alert("Node already exists!");
                }
            });

            // Add Connection Button
            document.getElementById("add-connection").addEventListener("click", () => {
                const from = document.getElementById("node-connect-from").value;
                const to = document.getElementById("node-connect-to").value;

                // 1) Check if nodes exist
                const fromNode = getNodeById(from);
                const toNode = getNodeById(to);

                if (!fromNode || !toNode) {
                    alert("Both nodes must exist. Create them first!");
                    return;
                }
                // 2) Prevent self-connections
                if (from === to) {
                    alert("Cannot connect a node to itself!");
                    return;
                }
                // 3) Prevent duplicates
                if (links.find(l => (l.source.id === from && l.target.id === to) || (l.source.id === to && l.target.id === from))) {
                    alert("These nodes are already connected!");
                    return;
                }

                // Everything is valid, so add the link
                links.push({ source: fromNode, target: toNode });
                updateGraph();
            });

            // Responsive SVG
            window.addEventListener("resize", () => {
                const newWidth = document.getElementById("graph-container").clientWidth;
                svg.attr("width", newWidth);
                simulation.force("center", d3.forceCenter(newWidth / 2, height / 2));
                simulation.alpha(1).restart();
            });

            /******************************************
             *  Simple Contact Form Handling          *
             ******************************************/
            const contactForm = document.getElementById("contact-form");
            contactForm.addEventListener("submit", (e) => {
                e.preventDefault();
                const name = sanitizeInput(document.getElementById("name").value);
                const email = sanitizeInput(document.getElementById("email").value);
                const message = sanitizeInput(document.getElementById("message").value);

                // Basic validation
                if (name && validateEmail(email) && message) {
                    alert(
                        "Thank you for reaching out!\n\n" +
                        "Name: " + name + "\n" +
                        "Email: " + email + "\n" +
                        "Message: " + message + "\n\n" +
                        "We will respond to your inquiry shortly."
                    );
                    contactForm.reset();
                } else {
                    alert("Please fill out all fields correctly.");
                }
            });

            // Sanitize input to prevent XSS
            function sanitizeInput(str) {
                return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            }

            // Validate email format
            function validateEmail(email) {
                const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return re.test(String(email).toLowerCase());
            }

            /******************************************
             *  Mobile Menu Toggle                     *
             ******************************************/
            const mobileMenuButton = document.querySelector(".mobile-menu-button");
            const navUl = document.querySelector("nav ul");

            mobileMenuButton.addEventListener("click", () => {
                navUl.classList.toggle("active");
            });

            /******************************************
             *  Dark Mode Toggle                       *
             ******************************************/
            const darkModeToggle = document.querySelector(".dark-mode-toggle");
            darkModeToggle.addEventListener("click", () => {
                document.body.classList.toggle("dark-mode");
                updateGraphColors();
                updateFooterColors();
                updateFormColors();
                updateHeroColors();
            });

            function updateGraphColors() {
                svg.selectAll(".link")
                    .attr("stroke", document.body.classList.contains("dark-mode") ? "#555" : "#999");

                svg.selectAll(".node")
                    .attr("fill", document.body.classList.contains("dark-mode") ? "#ff4081" : "#6a11cb");
            }

            function updateFooterColors() {
                // Footer styles are handled via CSS
            }

            function updateFormColors() {
                // Form styles are handled via CSS
            }

            function updateHeroColors() {
                // Hero section styles are handled via CSS
            }

            /******************************************
             *  Active Nav Link Highlighting           *
             ******************************************/
            const sections = document.querySelectorAll("section");
            const navLinks = document.querySelectorAll("nav a");

            window.addEventListener("scroll", () => {
                let current = "";
                sections.forEach(section => {
                    const sectionTop = section.offsetTop - 100;
                    if (pageYOffset >= sectionTop) {
                        current = section.getAttribute("id");
                    }
                });

                navLinks.forEach(link => {
                    link.classList.remove("active");
                    if (link.getAttribute("href") === "#" + current) {
                        link.classList.add("active");
                    }
                });
            });
        });
    </script>
</body>

</html>
